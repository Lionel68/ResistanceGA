<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>ResistanceGA</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>





<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!-- rmarkdown v1 -->

<!--
%\VignetteEngine{knitr::markdown}
%\VignetteIndexEntry{A Vignette/Tutorial to use ResistanceGA}
-->

<h1>ResistanceGA</h1>

<h2>An R Package for Optimizing Resistance Surfaces using Genetic Algorithms</h2>

<h3>Background</h3>

<p>With this vignette/tutorial, hopefully you&#39;ll get an idea of what each of the functions in this package can do, as well present an example (using simulated data) of how you can optimize resistance surfaces in isolation as well as simultaneously to create novel resistance surfaces. This &#39;package&#39; (I use that term very loosely) has largely been developed from functions I wrote to conduct different landscape genetic analyses. See <a href="http://onlinelibrary.wiley.com/doi/10.1111/mec.12747/abstract" title="Published Molecular Ecology Study">Peterman et al. (2014)</a> for the original conception of optimizing resistance surfaces using optimization functions. This approach was limited to optimization of continuous surfaces in isolation. Since that paper, I&#39;ve further developed the optimization method to utilize genetic algorithms, implemented using the <code>ga</code> function from the <a href="http://cran.r-project.org/web/packages/GA/index.html" title="GA package, CRAN">GA package</a> in R. By moving to genetic algorithms, much more complex parameter space can be effectively searched, which allows for the optimization of categorical resistance surfaces, as well as optimization of multiple resistance surfaces simultaneously. </p>

<p>This package fills a void in the landscape genetics toolbox. There are various methods proposed for determining resistance values (reviewed by <a href="http://onlinelibrary.wiley.com/doi/10.1111/j.1365-294X.2010.04657.x/abstract" title="Spear et al.">Spear et al., 2010</a>). Previously utilized methods generally searched a limited parameter space and/or relied on expert opinion. <a href="http://onlinelibrary.wiley.com/doi/10.1111/mec.12348/abstract" title="Graves et al.">Graves et al. (2013)</a> utilized optimization functions and interindividual genetic distances to determine resistance values, but found that the data generating values were rarely recoverable. I have not assessed the ability of functions/methods utilized in this package to optimize resistance surfaces as in Graves et al. (2013), but do note that very different methods of scaling, transforming, and combining resistance surfaces are utilized in <code>ResistanceGA</code>.</p>

<p>A few words of caution. I have made every effort to run and test each function with simulated data, but I make no guarantees concerning function performance and stability. Data formatting can be a challenge, and I have tried to simplify the process as much as possible. If you choose to optimize using CIRCUITSCAPE, Please make sure you carefully read through the <a href="http://www.circuitscape.org/home" title="CIRCUITSCAPE">CIRCUITSCAPE</a> documentation, as well as other relevant papers by <a href="http://www.circuitscape.org/pubs" title="McRae papers">Brad McRae</a> to get a more complete understanding of resistance modeling and circuit theory. If errors occur, start by making sure that you are providing function inputs in the correct format. If a function does not work, there likely will not be a helpful error message to help you troubleshoot. Depending on interest and use, these are features that may be added in the future. Lastly, this is not a fast process. Even with the 50x50 pixel simulated landscapes used in this tutorial, each (CIRCUITSCAPE) optimization iteration takes 0.75--1.00 seconds to complete (Intel i7 3.4 GHz processor, 24 GB RAM). Optimizing using least cost paths is ~3x faster than with CIRCUITSCAPE. To further reduce optimization time when using least cost paths, the optimization can be run in parallel. It appears that under most circumstances the resolution of the landscape can be reduced without loss of information (<a href="http://www.esajournals.org/doi/abs/10.1890/07-1861.1" title="McRae et al.">McRae et al., 2008</a>). If you want to use the optimization procedures in <code>ResistanceGA</code>, but are working with a large landscape, I might suggest reducing the resolution first. Depending upon whether you are optimizing a single surface or multiple surfaces simultaneously, the genetic algorithms typically run for 50--300 generations. <code>ga</code> settings will vary for each run, but there will typically be 50--150 offspring (i.e. different parameter value realizations) per generation. This means that 2500--4.5 &times; 10<sup>4</sup> iterations will be needed to complete the optimization. This can be a <strong>LONG</strong> process! If you encounter issues while executing any of these functions, or would like some other functionality incorporated, please let me know (<a href="mailto:bill.peterman@gmail.com">bill.peterman@gmail.com</a>). I am eager to make this as accessible, functional, and as useful as possible, so any and all feedback is appreciated.</p>

<p><strong>References</strong>   </p>

<ul>
<li>Graves, T. A., P. Beier, and J. A. Royle. 2013. Current approaches using genetic distances produce poor estimates of landscape resistance to               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interindividual dispersal. Molecular Ecology 22:3888--3903.</li>
<li>McRae, B. H., B. G. Dickson, T. H. Keitt, and V. B. Shah. 2008. Using circuit theory to model connectivity in ecology, evolution, and<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conservation. Ecology 89:2712--2724.</li>
<li>Peterman, W. E., G. M. Connette, R. D. Semlitsch, and L. S. Eggert. in press. Ecological resistance surfaces predict fine scale genetic<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;differentiation in a terrestrial woodland salamander. Molecular Ecology 23:2402--2413.<br></li>
<li>Spear, S. F., N. Balkenhol, M. J. Fortin, B. H. McRae, and K. Scribner. 2010. Use of resistance surfaces for landscape genetic studies:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;considerations for parameterization and analysis. Molecular Ecology 19:3576--3591.</li>
</ul>

<h2>Setup</h2>

<h3>Install necessary software and packages</h3>

<p>If you want to optimize using CIRCUITSCAPE, this package requires that you have <a href="http://www.circuitscape.org/downloads" title="CS Downloads">CIRCUITSCAPE v4.0</a> or higher installed on your Windows machine. At this point in time, <code>ResistanceGA</code> has only been tested on <em>WINDOWS</em> operating systems. Ability to run on Mac or Linux systems is in testing. You will also need to have <a href="http://www.r-project.org/" title="R downloads">R &gt;= v3.0</a> installed. I would highly recommend installing <a href="https://www.rstudio.com/ide/download/" title="R Studio download">R studio</a> when working with R.</p>

<p><em>R Packages</em><br>
This package consists of several wrapper functions for implementing functions from other packages, and these will all be imported when <code>ResistanceGA</code> is installed.   </p>

<h2>Demonstrations</h2>

<h3>Continuous surface transformations</h3>

<p>First, install <code>ResistanceGA</code> from GitHub. This will require the <code>devtools</code> package</p>

<pre><code class="r"># Install &#39;devtools&#39; package, if needed
if(!(&quot;devtools&quot; %in% list.files(.libPaths()))) {
    install.packages(&quot;devtools&quot;, repo = &quot;http://cran.rstudio.com&quot;, dep = TRUE) 
}

library(devtools) # Loads devtools

install_github(&quot;wpeterman/ResistanceGA&quot;) # Download package
</code></pre>

<p>Load <code>ResistancaGA</code> and clear your workspace.</p>

<pre><code class="r">library(ResistanceGA)
rm(list = ls())
</code></pre>

<p>There are 8 different transformations that can be applied to continuous surfaces. Since the publication of Peterman et al. (2014), I have added Reverse Ricker and Inverse-Reverse Ricker transformation to better cover parameter space. I still think that there are more flexible ways to optimize surfaces, and I&#39;m continuing to develop these as I have time.<br>
<img src="figure/Transformations.png" alt="Transformations"></p>

<p>All of these figures were made with the <code>Plot.trans</code> function. This function returns a ggplot object, which allows you to manipulate some aspects of the plot, as well as determine the resistance value at different levels of your original surface.</p>

<pre><code class="r">Ricker.plot &lt;- Plot.trans(PARM=c(1.5, 200),Resistance=c(1,10),transformation=&quot;Ricker&quot;)
</code></pre>

<p><img src="figure/Plot.trans.demo-1.png" alt="plot of chunk Plot.trans.demo"> </p>

<pre><code class="r"># Change title of plot
Ricker.plot$labels$title&lt;-&quot;Ricker Tansformation&quot;
Ricker.plot
</code></pre>

<p><img src="figure/Plot.trans.demo-2.png" alt="plot of chunk Plot.trans.demo"> </p>

<pre><code class="r"># Find original data value that now has maximum resistance
Ricker.plot$data$original[which(Ricker.plot$data$transformed==max(Ricker.plot$data$transformed))]
</code></pre>

<pre><code>## [1] 2.356784
</code></pre>

<h2>Example Function Use</h2>

<h3>Single surface optimization (with simulated data)</h3>

<p>Make a directory to write ASCII files, CIRCUITSCAPE batch files, and results. It is critical that there are <strong>NO SPACES</strong> in the specified directory as this will cause functions that interact with CIRCUITSCAPE to fail.  </p>

<pre><code class="r">if(&quot;ResistanceGA_Examples&quot;%in%dir(&quot;C:/&quot;)==FALSE) 
  dir.create(file.path(&quot;C:/&quot;, &quot;ResistanceGA_Examples&quot;)) 

# Create a subdirectory for the first example
dir.create(file.path(&quot;C:/ResistanceGA_Examples/&quot;,&quot;SingleSurface&quot;)) 

write.dir &lt;- &quot;C:/ResistanceGA_Examples/SingleSurface/&quot;      # Directory to write .asc files and results

# Give path to CIRCUITSCAPE .exe file
# Default = &#39;&quot;C:/Program Files/Circuitscape/cs_run.exe&quot;&#39;
CS.program &lt;- paste(&#39;&quot;C:/Program Files/Circuitscape/cs_run.exe&quot;&#39;)
</code></pre>

<p>Load resistance surfaces and export as <em>.asc</em> file for use with CIRCUITSCAPE. These surfaces were made using the <code>RandomFields</code> package</p>

<pre><code class="r">data(resistance_surfaces)
continuous &lt;- resistance_surfaces[[2]]
writeRaster(continuous,filename=paste0(write.dir,&quot;cont.asc&quot;),overwrite=TRUE)
</code></pre>

<p>Load the example sample location data and export as <em>.txt</em> file. This is formatted for input into CIRCUITSCAPE</p>

<pre><code class="r">data(samples)
write.table(samples,file=paste0(write.dir,&quot;samples.txt&quot;),sep=&quot;\t&quot;,col.names=F,row.names=F)

# Create a spatial points object for plotting
sample.locales &lt;- SpatialPoints(samples[,c(2,3)])
</code></pre>

<p>Plot surface and overlay the sample points</p>

<pre><code class="r">plot(continuous)
plot(sample.locales, pch=16, col=&quot;blue&quot;, add=TRUE) # Add points
</code></pre>

<p><img src="figure/single.surface.plot-1.png" alt="plot of chunk single.surface.plot"> </p>

<h2>Prepare data for optimization</h2>

<p>Run the <code>GA.prep</code> and <code>CS.prep</code> functions</p>

<pre><code class="r"># Set the random number seed to reproduce the results presented
GA.inputs &lt;- GA.prep(ASCII.dir=write.dir,
                   max.cat=500,
                   max.cont=500,
                   seed = 555) 

CS.inputs &lt;- CS.prep(n.POPS=length(sample.locales),
                   CS_Point.File=paste0(write.dir,&quot;samples.txt&quot;),
                   CS.program=CS.program) 
</code></pre>

<p>Note that <code>response</code> was not defined in <code>CS.prep</code> because it has not been made yet.</p>

<p>Transform raw continuous surface using the <code>Resistance.tran</code> function to apply one of the eight transformations, and then view the transformation using <code>Plot.trans</code>. Note that <code>Plot.trans</code> returns a <code>ggplot2</code> object as well as the plot. Therefore you can manipulate and modify the plot as desired.</p>

<pre><code class="r">r.tran &lt;- Resistance.tran(transformation=&quot;Monomolecular&quot;, shape=2, max=275, r=continuous) 

plot.t &lt;- Plot.trans(PARM=c(2,275), Resistance=continuous, transformation=&quot;Monomolecular&quot;) 
</code></pre>

<p><img src="figure/monomolec.plot-1.png" alt="plot of chunk monomolec.plot"> </p>

<p>Run the transformed resistance surface through CIRCUITSCAPE to get effective resistance between each pair of points. <code>Run.CS</code> returns the lower half of the pairwise resistance matrix for use with the optimization prep functions. This will be our response that we optimize on.</p>

<pre><code class="r"># Create the true resistance/response surface
CS.response &lt;- Run_CS(CS.inputs=CS.inputs,GA.inputs=GA.inputs, r=r.tran)
</code></pre>

<p>Rerun <code>CS.prep</code> including the newly created <code>CS.response</code></p>

<pre><code class="r">CS.inputs &lt;- CS.prep(n.POPS=length(sample.locales),
                   response=CS.response,
                   CS_Point.File=paste0(write.dir,&quot;samples.txt&quot;),
                   CS.program=CS.program)
</code></pre>

<p>Run the Single surface optimization function (<code>SS_optim</code>). Running this example with the default settings
took 147 iterations and ~72 minutes to complete on a computer with an Intel i7 3.4 GHz processor. The data generating values have been precisely recovered.   </p>

<pre><code class="r">SS_RESULTS &lt;- SS_optim(CS.inputs=CS.inputs,
                       GA.inputs=GA.inputs)
</code></pre>

<p>View the results and compare with truth   </p>

<pre><code>SS_table &lt;- data.frame(c(&quot;Monomolecular&quot;, 2.0, 275),
                        t(SS_RESULTS$ContinuousResults[c(3:5)]))
colnames(SS_table) &lt;- c(&quot;Truth&quot;, &quot;Optimized&quot;)

SS_table
                 Truth     Optimized
Equation Monomolecular Monomolecular
shape                2      1.999999
max                275      274.9982
</code></pre>

<p>If you get the error:</p>

<pre><code>Error in initializePtr() : 
  function &#39;dataptr&#39; not provided by package &#39;Rcpp&#39;
</code></pre>

<p>Reinstall the <code>Rcpp</code> package and execute the <code>SS_optim</code> function again.</p>

<p>After executing the function, the console will be updated to report the time to complete each iteration as well as AICc of each iteration. If you do not wish to view updates at each iteration of the optimization, set <code>quiet = TRUE</code> in <code>GAp.prep</code></p>

<p>What the <code>SS_optim</code> function does:       </p>

<ul>
<li>Read each .asc file that is in the specified ASCII.dir and determines whether it is a categorical or continuous surface. A surface is considered categorical if it contains 15 or fewer unique values.<br></li>
<li>Optimize each resistance surface<br>

<ul>
<li>Categorical surfaces: Each optimized value represents the resistance of that category to current flow<br></li>
<li>Continuous surfaces: Each continuous surface is first rescaled so that values range from 0--10 (note that relative spacing is preserved during rescaling). The genetic algorithm then tests different combinations of the transformation equation, shape parameter value, and maximum resistance value. When the genetic algorithm has finished optimization, the optimized parameters can be passed to a second optimization function that uses <code>nlm</code> to fine-tune the shape and maximum value parameters (<code>nlm = TRUE</code>). However, this approach may lead to overfitting and the default is <code>nlm = FALSE</code>.<br></li>
</ul></li>
<li>Several summary outputs are generated<br>

<ul>
<li>In the &#39;Results&#39; directory (located in the directory with the .asc files), a final optimized resistance .asc file has been made, along with the CIRCUITSCAPE results (.out files).<br></li>
<li>Summary tables for continuous surfaces (ContinuousResults.csv), categorical surfaces (CategoricalResults.csv), and the AICc of all surfaces (All_Results_AICc.csv)<br></li>
<li>MLPE_coeff_Table.csv contains the model coefficients from the fitted mixed effects model for each surface<br></li>
<li>In the &#39;Plots&#39; directory there is a 4-panel figure with different model diagnostic plots generated from the fitted mixed effects model of each optimized resistance surface. If a continuous surface was optimized, there is also a plot showing the relationship of the transformed resistance surface with the original data.<br></li>
</ul></li>
<li>The returned object is a named list containing the tables described above.<br></li>
</ul>

<p>To view the AICc response surface for the Monomolecular optimization of this surface, you can run <code>Grid.Search</code>. This function is only relevant for single continuous surfaces.</p>

<pre><code class="r">Grid.Results &lt;- Grid.Search(shape=seq(1,4,by=0.1),
                            max=seq(50,500,by=75),
                            transformation=&quot;Monomolecular&quot;,
                            Resistance=continuous, 
                            CS.inputs, 
                            GA.inputs=GA.inputs)
</code></pre>

<p><img src="figure/grid_topo.png" alt="GRID.Surface">      </p>

<p>You can change the color scheme and color breaks by manually recreating the response surface from the generated data [default = topo.colors(20)]</p>

<pre><code class="r">filled.contour(Grid.Results$Plot.data,
               col=rainbow(30),
               xlab=&quot;Shape parameter&quot;,
               ylab=&quot;Maximum value parameter&quot;)
</code></pre>

<p><img src="figure/Raindow_Surface.png" alt="GRID.Surface.update">    </p>

<p>Note that actual response surfaces tend to be slightly flatter, and the maximum value for a single surface is more difficult to identify precisely. If you were to add some random noise to the CS.response, the single surface optimization generally would do a good job of recovering the transformation and shape parameters, but the true maximum value may remain elusive. Occasionally the algorithm will get &#39;stuck&#39; trying to optimize on an incorrect transformation. If this happens, rerun the optimization. Of course, you may not know that a surface wasn&#39;t correctly optimized when using real data. For this reason, it is good practice to run all optimizations at least twice to confirm parameter estimates.   </p>

<h3>Minimum code for running ResistanceGA</h3>

<p>The example above outlines how the functions can be used while simulating and generating data with known parameter values. When analyzing your own data, it is not necessary to to use the <code>r.tran</code> or <code>Run_CS</code> functions. You should only have to use the following functions (although you may want to change settings from defaults).</p>

<pre><code class="r">GA.inputs &lt;- GA.prep(ASCII.dir=write.dir) 

CS.inputs &lt;- CS.prep(n.POPS=length(sample.locales),
                     response=CS.response,
                     CS_Point.File=paste0(write.dir,&quot;samples.txt&quot;),
                     CS.program=CS.program)

SS_RESULTS &lt;- SS_optim(CS.inputs=CS.inputs,
                       GA.inputs=GA.inputs)
</code></pre>

<h1>Optimzation using least cost paths</h1>

<p>The above optimization can also be done using cost distances calculated in <code>gdistance</code>. This approach uses least cost paths between points, so it is a simpler representation of connectivity. However, optimization using <code>gdistance</code> is ~3x faster than optimization with CIRCUITSCAPE. This optimization took 86 iterations and 7 minutes to complete when run in parallel on 4 cores (<code>parallel = 4</code> in <code>GA.prep</code>)</p>

<pre><code class="r"># Import data
data(resistance_surfaces)
continuous &lt;- resistance_surfaces[[2]]

data(samples)
sample.locales &lt;- SpatialPoints(samples[,c(2,3)])

# Set the random number seed to reproduce the results presented
# Run in parallel on 4 cores
GA.inputs &lt;- GA.prep(ASCII.dir=continuous,
                     Results.dir=write.dir,
                     max.cat=500,
                     max.cont=500,
                     seed = 555,
                     parallel = 4) 

gdist.inputs &lt;- gdist.prep(n.POPS=length(sample.locales),
                           samples=sample.locales)

# Transform resistance surface
r.tran &lt;- Resistance.tran(transformation=&quot;Monomolecular&quot;, shape=2, max=275, r=continuous) 

# Create the true resistance/response surface
gdist.response &lt;- Run_gdistance(gdist.inputs=gdist.inputs, r=r.tran)

# Rerun `gdist.prep` to include response
gdist.inputs &lt;- gdist.prep(n.POPS=length(sample.locales),
                           response=lower(as.matrix(gdist.response)),
                           samples=sample.locales)

# Run optimization
SS_RESULTS.gdist &lt;- SS_optim(gdist.inputs=gdist.inputs,
                             GA.inputs=GA.inputs)

# Grid search of response surface
Grid.Results.gdist &lt;- Grid.Search(shape=seq(1,4,by=0.1),
                                  max=seq(50,500,by=75),
                                  transformation=&quot;Monomolecular&quot;,
                                  Resistance=continuous, 
                                  gdist.inputs=gdist.inputs, 
                                  GA.inputs=GA.inputs)
</code></pre>

<hr>

<h3>Simultaneous optimization of multiple surfaces</h3>

<p>First, make a new directory to write ASCII files, CIRCUITSCAPE batch files, and results.</p>

<pre><code class="r">if(&quot;ResistanceGA_Examples&quot;%in%dir(&quot;C:/&quot;)==FALSE) 
  dir.create(file.path(&quot;C:/&quot;, &quot;ResistanceGA_Examples&quot;)) 

# Create a subdirectory for the second example
dir.create(file.path(&quot;C:/ResistanceGA_Examples/&quot;,&quot;MultipleSurfaces&quot;)) 

# Directory to write .asc files and results
write.dir &lt;- &quot;C:/ResistanceGA_Examples/MultipleSurfaces/&quot;      
</code></pre>

<p>Extract other resistance surfaces from the &#39;resistance_surfaces&#39; raster stack</p>

<pre><code class="r">data(resistance_surfaces)
data(samples)
sample.locales &lt;- SpatialPoints(samples[ ,c(2,3)])
</code></pre>

<p>Visualize each surface:</p>

<pre><code class="r">plot(resistance_surfaces[[1]],main = resistance_surfaces[[1]]@data@names)
plot(sample.locales, pch=16, col=&quot;blue&quot;, add=TRUE)
</code></pre>

<p><img src="figure/feature.sim-1.png" alt="plot of chunk feature.sim"> </p>

<pre><code class="r">plot(resistance_surfaces[[2]],main = resistance_surfaces[[2]]@data@names)
plot(sample.locales, pch=16, col=&quot;blue&quot;, add=TRUE)
</code></pre>

<p><img src="figure/feature.sim-2.png" alt="plot of chunk feature.sim"> </p>

<pre><code class="r">plot(resistance_surfaces[[3]],main = resistance_surfaces[[3]]@data@names)
plot(sample.locales, pch=16, col=&quot;blue&quot;, add=TRUE)
</code></pre>

<p><img src="figure/feature.sim-3.png" alt="plot of chunk feature.sim"> </p>

<p>Write all three surfaces to a directory for use with CIRCUITSCAPE and run the <code>GA.prep</code> function (needed to combine surfaces). Also write the sample location file to the &quot;MultipleSurfaces&quot; directory.</p>

<pre><code class="r">writeRaster(categorical,filename=paste0(write.dir,&quot;cat.asc&quot;),overwrite=TRUE)
writeRaster(continuous,filename=paste0(write.dir,&quot;cont.asc&quot;),overwrite=TRUE)
writeRaster(feature,filename=paste0(write.dir,&quot;feature.asc&quot;),overwrite=TRUE)

write.table(samples,file=paste0(write.dir,&quot;samples.txt&quot;),sep=&quot;\t&quot;,col.names=F,row.names=F)
</code></pre>

<p>Run <code>GA.prep</code></p>

<pre><code class="r">GA.inputs &lt;- GA.prep(ASCII.dir=write.dir,
                   max.cat=500,
                   max.cont=500,
                   seed = 555,
                   quiet = TRUE) 
</code></pre>

<p>Transform, reclassify, and combine the three resistance surfaces together. Use an &quot;Inverse-Reverse Monomolecular&quot; transformation of the continuous surface. Visualize this transformation using <code>Plot.trans</code>. The first value of <code>PARM</code> refers to the shape parameter, and the second value refers to the maximum value parameter. Look in the help file for <code>Plot.trans</code> for transformation names/numbers.</p>

<pre><code class="r">plot.t &lt;- Plot.trans(PARM=c(3.5,400),Resistance=continuous,transformation=&quot;Reverse Ricker&quot;) 
</code></pre>

<p><img src="figure/reverse.ricker-1.png" alt="plot of chunk reverse.ricker"> </p>

<p>Combine raster surfaces together using <code>Combine_Surfaces</code>. Note that the .asc files are read in alphabetically. You can check the order of surfaces by inspecting <code>GA.inputs$layer.names</code>. First, define the parameters that will be passed to <code>Combine_Surfaces</code>.   </p>

<pre><code class="r">PARM &lt;- c(1, 250, 75, 6, 3.5, 150, 1, 350)

# PARM&lt;- c(1,   # First feature of categorical   
#          250, # Second feature of categorical   
#          75,  # Third feature of categorical     
#          6,   # Transformation equation for continuous surface    
#          3.5,   # Shape parameter    
#          150, # Scale parameter 
#          1,   # First feature of feature surface    
#          350) # Second feature of feature surface   

# Combine resistance surfaces
Resist &lt;- Combine_Surfaces(PARM=PARM, 
                           CS.inputs=CS.inputs, 
                           GA.inputs=GA.inputs, 
                           out=NULL, 
                           rescale = TRUE)

# View combined surface
plot(Resist,  main = &quot;scaled composite resistance&quot;)
</code></pre>

<p><img src="figure/combine_surfaces.png" alt="RESIST.Surface"> </p>

<p>Generate new CS response surface by using <code>Run_CS</code> and run <code>CS.prep</code> to add response</p>

<pre><code class="r"># Create the true resistance/response surface
CS.response &lt;- Run_CS(CS.inputs=CS.inputs, GA.inputs=GA.inputs, r=Resist)

CS.inputs&lt;-CS.prep(n.POPS=length(sample.locales),
                      response=CS.response,
                      CS_Point.File=paste0(write.dir,&quot;samples.txt&quot;),
                      CS.program=CS.program)
</code></pre>

<p>Run <code>MS_optim</code>. Running this multisurface example with the default settings took 257 iterations and ~5 hours to complete on a computer with an Intel i7 3.4 GHz processor.</p>

<pre><code class="r">Multi.Surface_optim &lt;- MS_optim(CS.inputs=CS.inputs,
                               GA.inputs=GA.inputs)
</code></pre>

<p>After executing the function, the console will be updated to report the time to complete each iteration as well as AICc of each iteration. </p>

<p>What the <code>MS_optim</code> function does:       </p>

<ul>
<li>Read all .asc files that are in the specified ASCII.dir, makes a raster stack, and determines whether each is a categorical or continuous surface. A surface is considered categorical if it contains 15 or fewer unique values.<br></li>
<li>Transformation and resistance values are chosen for each surface, all surfaces are added together, and AICc from the mixed effects model is calculated.<br></li>
<li>Several summary outputs are generated<br>

<ul>
<li>In the &#39;Results&#39; directory (located in the directory with the .asc files), a final optimized resistance .asc file has been made (the name is a combination of the layers optimized, separated by &quot;.&quot;), along with the CIRCUITSCAPE results (.out files).<br></li>
<li>&#39;Multisurface_Optim_Summary.txt&#39; provides a text summary of the model parameters and results of the multisurface optimization<br></li>
<li>A .csv file with the fitted MLPE model coefficients</li>
<li>In the &#39;Plots&#39; directory there is a 4-panel figure with different model diagnostic plots generated from the fitted mixed effects model of each optimized resistance surface.<br></li>
</ul></li>
<li>The <code>GA</code> object from the optimization is returned and can be further explored.<br></li>
</ul>

<p>The multisurface optimization procedure has done a pretty good job of recovering the relative data generating values. You&#39;ll notice that we have not exactly recovered the values, but that the relative relationship among surfaces is preserved (see below).</p>

<pre><code class="r">Summary.table &lt;- data.frame(PARM,round(t(Multi.Surface_optim@solution),2))
colnames(Summary.table)&lt;-c(&quot;Truth&quot;, &quot;Optimized&quot;)
row.names(Summary.table)&lt;-c(&quot;Category1&quot;, 
                            &quot;Category2&quot;, 
                            &quot;Category3&quot;, 
                            &quot;Transformation&quot;, 
                            &quot;Shape&quot;, 
                            &quot;Max&quot;, 
                            &quot;Feature1&quot;, 
                            &quot;Feature2&quot;) 
</code></pre>

<pre><code>Summary.table
               Truth Optimized
Category1        1.0      1.00
Category2      250.0    304.31
Category3       75.0     91.15
Transformation   6.0      6.28
Shape            3.5      3.50
Max            150.0    183.12
Feature1         1.0      1.00
Feature2       350.0    426.14
</code></pre>

<p>The optimized values are ~1.22 times greater than the data generating values. However, if we rescale both the true and optimized resistance surfaces to have a minimum value of 1, we see that the surfaces are identical. The values for the 3-class categorical surface are the first three values listed, the continuous surface values = 4--6 , and the feature surface values = 7--8. Note that the first value for continuous surfaces identifies the transformation used (the fourth value, here), and is always rounded down (6 = Reverse Ricker). Visualize and test the equivalence of simulated and optimized resistance surfaces:   </p>

<pre><code class="r"># Make combined, optimized resistance surface.
optim.resist &lt;- Combine_Surfaces(PARM=Multi.Surface_optim@solution, CS.inputs =  CS.inputs,GA.inputs =  GA.inputs, rescale = TRUE)
ms.stack &lt;- stack(Resist, optim.resist)
names(ms.stack) &lt;- c(&quot;Truth&quot;, &quot;Optimized&quot;)
plot(ms.stack) 

# Correlation between the two surfaces
pairs(ms.stack)
</code></pre>

<p><img src="figure/combined_plots.png" alt="combined.plots">     </p>

<p><img src="figure/correlation_plot.png" alt="correlation.plots">       </p>

<p>If you want to create a <code>CIRCUITSCAPE</code> current map from either the true or optimized surfaces, this can be done by setting <code>CurrentMap=TRUE</code> and <code>output=&quot;raster&quot;</code> in <code>Run_CS</code>.</p>

<pre><code class="r">Resist.true &lt;- Run_CS(CS.inputs=CS.inputs, 
                      GA.inputs=GA.inputs, 
                      r=Resist, 
                      CurrentMap=TRUE, 
                      output=&quot;raster&quot;)

Resist.opt &lt;- Run_CS(CS.inputs=CS.inputs, 
                     GA.inputs=GA.inputs,
                     r=optim.resist,
                     CurrentMap=TRUE, 
                     output=&quot;raster&quot;)

# We can confirm that, like the resistance surfaces above, the CIRCUITSCAPE current maps are also correlated
cs.stack &lt;- stack(Resist.true, Resist.opt)
names(cs.stack) &lt;- c(&quot;Truth&quot;, &quot;Optimized&quot;)
pairs(cs.stack)
</code></pre>

<p><img src="figure/CS_corr.png" alt="CS_corr.plot"> </p>

<p>The optimization often converges on a highly correlated solution, but one that results in relative resistance values that are identical to those of the simulated data. This is important to understand, and interpretation of resistance values should be made with this fact in mind.   </p>

<h1>Multisurface optimization using least cost paths</h1>

<p>The multisurface optimization can also be run in parallel when using least cost paths. This can be done by setting <code>parallel = TRUE</code> or <code>parallel = #cores</code> in <code>GA.prep</code>. This example took 210 iterations to run in parallel on 4 cores, and completed in 38 minutes.</p>

<pre><code class="r"># Run `gdist.prep`
gdist.inputs&lt;-gdist.prep(n.POPS=length(sample.locales),                         
                         samples=sample.locales)

GA.inputs &lt;- GA.prep(ASCII.dir=resistance_surfaces,
                     Results.dir=write.dir,
                     max.cat=500,
                     max.cont=500,
                     seed = 999,
                     parallel = 4)

# Combine resistance surfaces
Resist &lt;- Combine_Surfaces(PARM=PARM,
                           gdist.inputs=gdist.inputs,
                           GA.inputs=GA.inputs,
                           out=NULL,
                           rescale=TRUE)

# Create the true resistance/response surface
gd.response &lt;- Run_gdistance(gdist.inputs=gdist.inputs,                             
                             r=Resist)

# Run `CS.prep` functions
gdist.inputs&lt;-gdist.prep(n.POPS=length(sample.locales),
                         response=lower(as.matrix(gd.response)),
                         samples=sample.locales)

# Run `MS_optim`
Multi.Surface_optim.gd &lt;- MS_optim(gdist.inputs=gdist.inputs,
                                   GA.inputs=GA.inputs)

summary(Multi.Surface_optim.gd)
</code></pre>

<p><strong>Comments on multiple surface optimization:</strong></p>

<ul>
<li>If the optimized resistance values are near the maximum value specified in <code>GA.prep</code>, it is recommended that you increase the maximum value and rerun the optimization.<br></li>
<li>If the optimization ends very quickly (e.g., &lt;40 iterations), you may want to increase the probability of mutation (<code>pmutation</code>) and/or the probability of crossover (<code>pcrossover</code>). These can be adjusted using <code>GA.prep</code>. I have not extensively tested these settings to determine optimal values, but found that the current defaults (pmutation = 0.125, pcrossover = 0.85) have generally worked quite well with simulated data and produced reproducible estimates with real data. Alternatively, because this is a stochastic optimization, just rerun the optimization (make sure you have not set a seed!)</li>
<li>Any and all settings of the <code>ga</code> function can be adjusted or customized. The main change made from the default setting for optimization of resistance surfaces was to use the &quot;gareal_blxCrossover&quot; method. This greatly improved the search of parameter space.</li>
<li>As mentioned above concerning single surface optimization: this is a stochastic optimization process and optimized values will likely differ from run to run. Despite the time involved, it is advised to run all optimizations at least twice to confirm parameter estimates/relative relationship among resistance surfaces. </li>
<li>While there is no established framework for how optimization of resistances surface can or should be done, below is a flowchart of how an analysis might proceed:<br></li>
</ul>

<p><img src="figure/FlowChart_Narrow2.png" alt="flowchart"> </p>

<h3>Summary</h3>

<p>Hopefully this vignette/tutorial has demonstrated the functions present in this package and how they can be used together to optimize resistance surfaces in isolation or in combination. These methods require no <em>a priori</em> assumptions by the researcher. Optimization is conducted solely on the genetic distance data provided.  The goal of this package is to make these methods accessible and useful to others. Development and advancement will continue as long as there is interest and there remains a need. Please contact me (<a href="mailto:bill.peterman@gmail.com">bill.peterman@gmail.com</a>) if you encounter issues with any of these functions, need assistance with interpretation, or would like other features added.</p>

<h3>Acknowledgements</h3>

<p>A huge thanks to Grant Connette for many discussions related to development and implementation of these methods!</p>

</body>

</html>
